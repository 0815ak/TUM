# C++

## Your Task
- Implement the `GpsConverter.frameReceived(canFrame)` function for extracting the **GPS data**
	- Convert the GPS-data from CAN to **Arc-milliseconds**
	- **Push**  the new coordinates to the Android part
- Run the **tests** from the project directory (using ruby), and ensure, that they pass

## GPS Datalayout in CAN Message

The frames are aligned as **Little Endian** (Least Significant Byte is at lowest address). The CAN-frame defines these bytes:

		Byte7 ST_LAT_NAVI
		Byte6 ST_LAT_NAVI
		Byte5 ST_LAT_NAVI
		Byte4 ST_LAT_NAVI
		Byte3 ST_LONG_NAVI
		Byte2 ST_LONG_NAVI
		Byte1 ST_LONG_NAVI
		Byte0 ST_LONG_NAVI

The payload is formated as the following format:

		Status Longitude Navigation
		ST_LONG_NAVI
		Range: -180° ...  +180°
		32 Bit Signed Integer (Byte 0 ... Byte 3)
		Invalid-Value: 80 00 00 00h
		Signal not available value: 7F FF FF FF
		
		
		Status Latitude Navigation
		ST_LAT_NAVI
		Range: -180° ...  +180°
		32 Bit Signed Integer (Byte 4 ... Byte 7)
		Invalid-Value: 80 00 00 00h
		Signal not available value: 7F FF FF FF


## Help/Advice
If the task is too difficult, you can use this help and advice section.

### Run tests
- Install the bake tool from  [http://esrlabs.github.io/bake/](http://esrlabs.github.io/bake/)
- execute `rake run` from this directory

### GPS on CAN
The raw data has to be converted to arc-milliseconds

    1°2'5" == (1*3600+ 2*60 + 5)*1000

Beware that the system you are running your code on will not support floating point operations.  
Use only unsigned and signed integers!  
Still the precision of your calculations has to be +-100 milli-arc-seconds

### Conversion to Arc-Degree
inDegree hex = 180/(2^31-1) * (hex) [°]